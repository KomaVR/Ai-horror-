<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flight Simulator Mobile 3D</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial; background: #87CEEB; touch-action: none; }
        canvas { width: 100%; height: 100vh; display: block; }
        #hud { position: absolute; top: 5px; left: 5px; color: white; text-shadow: 0 0 3px black; font-size: 14px; }
        #controls { position: absolute; bottom: 5px; left: 5px; z-index: 10; display: flex; flex-direction: column; }
        #startScreen { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.8); color: white; text-align: center; padding-top: 20%; 
            transition: opacity 1s; 
        }
        button { padding: 8px 16px; margin: 5px; background: #333; color: white; border: none; font-size: 12px; }
        input[type="range"] { width: 100px; margin: 5px 0; }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div id="hud">
        Alt: <span id="alt">0</span>m | Spd: <span id="spd">0</span>m/s | Fuel: <span id="fuel">100</span>%
    </div>
    <div id="controls">
        <input type="range" id="throttle" min="0" max="100" value="0">
    </div>
    <div id="startScreen">
        <h1>Flight Sim 3D</h1>
        <p>Tilt to steer, slide throttle to fly!</p>
        <button onclick="startGame()">Start</button>
    </div>
    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');
        if (!gl) { alert('WebGL not supported! Use a modern mobile browser.'); throw new Error('WebGL failed'); }

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Shaders
        const vsSource = `
            attribute vec3 aPosition;
            attribute vec3 aColor;
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            varying vec3 vColor;
            void main() {
                gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
                vColor = aColor;
            }
        `;
        const fsSource = `
            precision mediump float;
            varying vec3 vColor;
            void main() {
                gl_FragColor = vec4(vColor, 1.0);
            }
        `;

        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vsSource);
        gl.compileShader(vertexShader);
        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(vertexShader));
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fsSource);
        gl.compileShader(fragmentShader);
        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(fragmentShader));
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(program));
        gl.useProgram(program);

        // Plane geometry
        const planeVertices = new Float32Array([
            0.0, 0.3, 0.0,  1.0, 1.0, 1.0,  // Nose (white)
           -0.5, 0.0, 0.4,  0.8, 0.8, 0.8,  // Left wing
            0.5, 0.0, 0.4,  0.8, 0.8, 0.8,  // Right wing
           -0.2, 0.0,-0.5,  0.7, 0.7, 0.7,  // Tail left
            0.2, 0.0,-0.5,  0.7, 0.7, 0.7   // Tail right
        ]);
        const planeIndices = new Uint16Array([0, 1, 2, 0, 3, 4]);

        // Terrain geometry
        const terrainVertices = [];
        const terrainIndices = [];
        const gridSize = 20; // Minimal for mobile
        for (let x = -5; x < 5; x += 0.5) {
            for (let z = -5; z < 5; z += 0.5) {
                const y = Math.sin(x) * Math.cos(z) * 0.3;
                terrainVertices.push(x, y, z, 0.2, 0.5, 0.2); // Green
            }
        }
        for (let i = 0; i < gridSize - 1; i++) {
            for (let j = 0; j < gridSize - 1; j++) {
                const a = i * gridSize + j;
                const b = a + 1;
                const c = (i + 1) * gridSize + j;
                const d = c + 1;
                terrainIndices.push(a, b, d, a, d, c);
            }
        }

        const planeVBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, planeVBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, planeVertices, gl.STATIC_DRAW);
        const planeIBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, planeIBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, planeIndices, gl.STATIC_DRAW);

        const terrainVBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, terrainVBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(terrainVertices), gl.STATIC_DRAW);
        const terrainIBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, terrainIBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(terrainIndices), gl.STATIC_DRAW);

        const aPosition = gl.getAttribLocation(program, 'aPosition');
        const aColor = gl.getAttribLocation(program, 'aColor');
        gl.enableVertexAttribArray(aPosition);
        gl.enableVertexAttribArray(aColor);

        const modelViewMatrix = gl.getUniformLocation(program, 'uModelViewMatrix');
        const projectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');

        // Game state
        let pitch = 0, roll = 0, yaw = 0, throttle = 0, altitude = 2, speed = 0, posX = 0, posZ = 0;
        let fuel = 100, score = 0, gameState = 'start';
        const startScreen = document.getElementById('startScreen');

        // Mobile controls
        window.addEventListener('deviceorientation', (e) => {
            if (gameState !== 'flying') return;
            roll = Math.max(-0.5, Math.min(0.5, (e.beta || 0) * 0.02)); // Pitch control
            pitch = Math.max(-0.5, Math.min(0.5, (e.gamma || 0) * 0.02)); // Roll control
        });

        document.getElementById('throttle').addEventListener('input', (e) => {
            throttle = e.target.value / 100;
        });

        function startGame() {
            gameState = 'flying';
            startScreen.style.opacity = '0';
            setTimeout(() => startScreen.style.display = 'none', 1000);
        }

        function resetGame() {
            pitch = roll = yaw = 0;
            throttle = 0;
            altitude = 2;
            speed = 0;
            posX = 0;
            posZ = 0;
            fuel = 100;
            score = 0;
            gameState = 'flying';
            document.getElementById('endScreen').style.display = 'none';
        }

        function render() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            if (gameState === 'flying') {
                // Physics
                speed = Math.max(0.02, Math.min(0.3, speed + (throttle * 0.005 - speed * 0.01)));
                const lift = 1.2 * speed * speed * Math.sin(roll);
                altitude += lift - 0.015;
                posX += Math.cos(yaw) * speed;
                posZ += Math.sin(yaw) * speed;
                yaw += pitch * 0.03;
                fuel -= throttle * 0.015;

                const terrainHeight = Math.sin(posX) * Math.cos(posZ) * 0.3;
                if (altitude <= terrainHeight) {
                    gameState = 'crashed';
                    document.getElementById('endMsg').textContent = 'Crashed!';
                    document.getElementById('endScore').textContent = Math.floor(score);
                    document.getElementById('endScreen').style.display = 'block';
                } else if (fuel <= 0) {
                    gameState = 'crashed';
                    document.getElementById('endMsg').textContent = 'Out of Fuel!';
                    document.getElementById('endScore').textContent = Math.floor(score);
                    document.getElementById('endScreen').style.display = 'block';
                }

                score += speed * 0.5;

                // HUD
                document.getElementById('alt').textContent = altitude.toFixed(1);
                document.getElementById('spd').textContent = (speed * 100).toFixed(0);
                document.getElementById('fuel').textContent = Math.max(0, fuel.toFixed(0));
            }

            // Projection matrix
            const aspect = canvas.width / canvas.height;
            const pMatrix = [
                1.5 / aspect, 0, 0, 0,
                0, 1.5, 0, 0,
                0, 0, -1, -1,
                0, 0, -5, 1
            ];
            gl.uniformMatrix4fv(projectionMatrix, false, pMatrix);

            // Terrain
            gl.bindBuffer(gl.ARRAY_BUFFER, terrainVBuffer);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 24, 0);
            gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 24, 12);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, terrainIBuffer);
            const terrainMatrix = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                -posX, 0, -posZ, 1
            ];
            gl.uniformMatrix4fv(modelViewMatrix, false, terrainMatrix);
            gl.drawElements(gl.TRIANGLES, terrainIndices.length, gl.UNSIGNED_SHORT, 0);

            // Plane
            gl.bindBuffer(gl.ARRAY_BUFFER, planeVBuffer);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 24, 0);
            gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 24, 12);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, planeIBuffer);
            const planeMatrix = [
                Math.cos(yaw), Math.sin(roll) * 0.3, Math.sin(yaw), 0,
                -Math.sin(roll) * 0.3, 1, Math.sin(pitch) * 0.3, 0,
                -Math.sin(yaw), -Math.sin(pitch) * 0.3, Math.cos(yaw), 0,
                posX, altitude, posZ, 1
            ];
            gl.uniformMatrix4fv(modelViewMatrix, false, planeMatrix);
            gl.drawElements(gl.TRIANGLES, planeIndices.length, gl.UNSIGNED_SHORT, 0);

            requestAnimationFrame(render);
        }

        gl.clearColor(0.53, 0.81, 0.92, 1.0); // Sky blue
        gl.enable(gl.DEPTH_TEST);
        render();
    </script>
</body>
</html>
