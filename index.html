<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flight Simulator Mobile 3D (Third-Person, Drag)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial; background: #87CEEB; touch-action: none; }
        canvas { width: 100%; height: 100vh; display: block; }
        #hud { position: absolute; top: 5px; left: 5px; color: white; text-shadow: 0 0 3px black; font-size: 14px; }
        #controls { position: absolute; bottom: 5px; left: 5px; z-index: 10; }
        #startScreen { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.8); color: white; text-align: center; padding-top: 20%; 
            transition: opacity 1s; 
        }
        button { padding: 8px 16px; margin: 5px; background: #333; color: white; border: none; font-size: 12px; }
        input[type="range"] { width: 100px; margin: 5px 0; }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div id="hud">
        Alt: <span id="alt">0</span>m | Spd: <span id="spd">0</span>m/s
    </div>
    <div id="controls">
        <input type="range" id="throttle" min="0" max="100" value="0">
    </div>
    <div id="startScreen">
        <h1>Flight Sim 3D</h1>
        <p>Drag to steer, slide throttle to fly in 3rd person!</p>
        <button onclick="startGame()">Start</button>
    </div>
    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');
        if (!gl) {
            alert('WebGL not supported! Try a modern mobile browser (e.g., Chrome or Safari).');
            throw new Error('WebGL failed');
        }

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Shaders with debug output
        const vsSource = `
            attribute vec3 aPosition;
            attribute vec3 aColor;
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            varying vec3 vColor;
            void main() {
                gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
                vColor = aColor;
            }
        `;
        const fsSource = `
            precision mediump float;
            varying vec3 vColor;
            void main() {
                gl_FragColor = vec4(vColor, 1.0);
            }
        `;

        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vsSource);
        gl.compileShader(vertexShader);
        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
            alert('Vertex shader error: ' + gl.getShaderInfoLog(vertexShader));
            throw new Error('Vertex shader compilation failed');
        }
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fsSource);
        gl.compileShader(fragmentShader);
        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            alert('Fragment shader error: ' + gl.getShaderInfoLog(fragmentShader));
            throw new Error('Fragment shader compilation failed');
        }
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            alert('Program linking error: ' + gl.getProgramInfoLog(program));
            throw new Error('Program linking failed');
        }
        gl.useProgram(program);

        // Plane (simple triangle, visible in 3rd person)
        const planeVertices = new Float32Array([
            0.0, 0.5, 0.0,  1.0, 0.0, 0.0,  // Red nose
           -0.5,-0.5, 0.0,  0.0, 1.0, 0.0,  // Green left wing
            0.5,-0.5, 0.0,  0.0, 0.0, 1.0   // Blue right wing
        ]);
        const planeIndices = new Uint16Array([0, 1, 2]);

        // Terrain (flat square, green)
        const terrainVertices = new Float32Array([
           -10.0, 0.0,-10.0,  0.2, 0.5, 0.2,  // Bottom left
            10.0, 0.0,-10.0,  0.2, 0.5, 0.2,  // Bottom right
            10.0, 0.0, 10.0,  0.2, 0.5, 0.2,  // Top right
           -10.0, 0.0, 10.0,  0.2, 0.5, 0.2   // Top left
        ]);
        const terrainIndices = new Uint16Array([0, 1, 2, 0, 2, 3]);

        const planeVBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, planeVBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, planeVertices, gl.STATIC_DRAW);
        const planeIBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, planeIBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, planeIndices, gl.STATIC_DRAW);

        const terrainVBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, terrainVBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, terrainVertices, gl.STATIC_DRAW);
        const terrainIBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, terrainIBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, terrainIndices, gl.STATIC_DRAW);

        const aPosition = gl.getAttribLocation(program, 'aPosition');
        const aColor = gl.getAttribLocation(program, 'aColor');
        gl.enableVertexAttribArray(aPosition);
        gl.enableVertexAttribArray(aColor);

        const modelViewMatrix = gl.getUniformLocation(program, 'uModelViewMatrix');
        const projectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');

        // Game state (third-person view)
        let pitch = 0, roll = 0, yaw = 0, throttle = 0, altitude = 1, speed = 0, posX = 0, posZ = 0;
        let gameState = 'start';
        const startScreen = document.getElementById('startScreen');

        // Drag controls for mobile (third-person steering)
        let touchStart = { x: 0, y: 0 };
        let isDragging = false;

        canvas.addEventListener('touchstart', (e) => {
            if (gameState !== 'flying') return;
            e.preventDefault();
            touchStart.x = e.touches[0].clientX;
            touchStart.y = e.touches[0].clientY;
            isDragging = true;
        });

        canvas.addEventListener('touchmove', (e) => {
            if (!isDragging || gameState !== 'flying') return;
            e.preventDefault();
            const touchEnd = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            const deltaX = (touchEnd.x - touchStart.x) / canvas.width * 2; // Normalize to -1 to 1
            const deltaY = (touchEnd.y - touchStart.y) / canvas.height * 2;
            yaw += deltaX * 0.05; // Turn left/right
            roll = Math.max(-0.5, Math.min(0.5, roll + deltaY * 0.05)); // Climb/dive
            touchStart = touchEnd;
        });

        canvas.addEventListener('touchend', (e) => {
            if (!isDragging) return;
            e.preventDefault();
            isDragging = false;
        });

        document.getElementById('throttle').addEventListener('input', (e) => {
            throttle = e.target.value / 100;
        });

        function startGame() {
            gameState = 'flying';
            startScreen.style.opacity = '0';
            setTimeout(() => startScreen.style.display = 'none', 1000);
        }

        function render() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            if (gameState === 'flying') {
                // Physics (simplified for mobile)
                speed = Math.max(0, Math.min(0.3, speed + (throttle * 0.005 - speed * 0.01)));
                const lift = 1.2 * speed * speed * Math.sin(roll);
                altitude += lift - 0.01;
                posX += Math.cos(yaw) * speed;
                posZ += Math.sin(yaw) * speed;

                if (altitude <= 0) {
                    altitude = 0;
                    if (speed > 0.1) {
                        gameState = 'crashed';
                        document.getElementById('endMsg').textContent = 'Crashed!';
                        document.getElementById('endScore').textContent = '0';
                        document.getElementById('endScreen').style.display = 'block';
                    }
                }

                // HUD
                document.getElementById('alt').textContent = altitude.toFixed(1);
                document.getElementById('spd').textContent = (speed * 100).toFixed(0);
            }

            // Projection matrix (third-person view, wide for mobile)
            const aspect = canvas.width / canvas.height;
            const pMatrix = [
                1.5 / aspect, 0, 0, 0,
                0, 1.5, 0, 0,
                0, 0, -1, -1,
                0, 0, -5, 1  // Camera behind plane
            ];
            gl.uniformMatrix4fv(projectionMatrix, false, pMatrix);

            // Terrain (green square, larger for visibility)
            gl.bindBuffer(gl.ARRAY_BUFFER, terrainVBuffer);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 24, 0);
            gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 24, 12);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, terrainIBuffer);
            const terrainMatrix = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];
            gl.uniformMatrix4fv(modelViewMatrix, false, terrainMatrix);
            gl.drawElements(gl.TRIANGLES, terrainIndices.length, gl.UNSIGNED_SHORT, 0);

            // Plane (red-green-blue triangle, third-person behind)
            gl.bindBuffer(gl.ARRAY_BUFFER, planeVBuffer);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 24, 0);
            gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 24, 12);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, planeIBuffer);
            const planeMatrix = [
                Math.cos(yaw), Math.sin(roll) * 0.3, Math.sin(yaw), 0,
                -Math.sin(roll) * 0.3, 1, Math.sin(pitch) * 0.3, 0,
                -Math.sin(yaw), -Math.sin(pitch) * 0.3, Math.cos(yaw), 0,
                posX, altitude, posZ, 1
            ];
            gl.uniformMatrix4fv(modelViewMatrix, false, planeMatrix);
            gl.drawElements(gl.TRIANGLES, planeIndices.length, gl.UNSIGNED_SHORT, 0);

            // Third-person camera (behind and above plane)
            const viewMatrix = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                -posX - Math.cos(yaw) * 3, -altitude - 2, -posZ - Math.sin(yaw) * 3, 1
            ];
            gl.uniformMatrix4fv(modelViewMatrix, false, viewMatrix);

            requestAnimationFrame(render);
        }

        gl.clearColor(0.53, 0.81, 0.92, 1.0); // Sky blue
        gl.enable(gl.DEPTH_TEST);
        render();
    </script>
</body>
</html>
