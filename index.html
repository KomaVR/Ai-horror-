<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flight Sim</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100vh; display: block; }
        #controls { position: absolute; bottom: 10px; left: 10px; }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div id="controls">
        <input type="range" id="throttle" min="0" max="100" value="50">
    </div>
    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');
        if (!gl) alert('WebGL not supported!');

        // Resize canvas to fit screen
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Vertex Shader
        const vsSource = `
            attribute vec3 aPosition;
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            void main() {
                gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
            }
        `;

        // Fragment Shader (simple coloring)
        const fsSource = `
            precision mediump float;
            void main() {
                gl_FragColor = vec4(0.0, 0.5, 1.0, 1.0); // Sky blue
            }
        `;

        // Compile shaders
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vsSource);
        gl.compileShader(vertexShader);
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fsSource);
        gl.compileShader(fragmentShader);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // Simple plane geometry (triangle for demo)
        const vertices = new Float32Array([
            0.0,  0.5,  0.0,  // Top
           -0.5, -0.5,  0.0,  // Bottom-left
            0.5, -0.5,  0.0   // Bottom-right
        ]);
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const aPosition = gl.getAttribLocation(program, 'aPosition');
        gl.enableVertexAttribArray(aPosition);
        gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

        // Matrices
        const modelViewMatrix = gl.getUniformLocation(program, 'uModelViewMatrix');
        const projectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');

        // Flight variables
        let pitch = 0, roll = 0, throttle = 50, altitude = 10, speed = 0.1;

        // Device orientation for tilt controls
        window.addEventListener('deviceorientation', (event) => {
            roll = event.beta * 0.01;  // Tilt forward/back
            pitch = event.gamma * 0.01; // Tilt left/right
        });

        // Throttle control
        document.getElementById('throttle').addEventListener('input', (e) => {
            throttle = e.target.value / 100;
            speed = throttle * 0.2;
        });

        // Animation loop
        function render() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Simple physics
            altitude += Math.sin(roll) * speed - 0.01; // Gravity pulls down
            if (altitude < 0) altitude = 0;

            // Model-view matrix (rotate plane)
            const mvMatrix = [
                Math.cos(pitch), 0, Math.sin(pitch), 0,
                0, 1, 0, 0,
                -Math.sin(pitch), 0, Math.cos(pitch), 0,
                0, 0, -altitude, 1
            ];
            gl.uniformMatrix4fv(modelViewMatrix, false, mvMatrix);

            // Projection matrix (simple perspective)
            const pMatrix = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, -1, -1,
                0, 0, 0, 1
            ];
            gl.uniformMatrix4fv(projectionMatrix, false, pMatrix);

            gl.drawArrays(gl.TRIANGLES, 0, 3);
            requestAnimationFrame(render);
        }

        gl.clearColor(0.8, 0.9, 1.0, 1.0); // Light blue sky
        gl.enable(gl.DEPTH_TEST);
        render();
    </script>
</body>
</html>
